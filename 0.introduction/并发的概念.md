# 基本概念

## 多任务

多任务是指计算机系统在同一时间段内执行多个任务的能力。在操作系统中，多任务可以通过进程和线程来实现。例如，当你在电脑上同时打开浏览器、音乐播放器和文档编辑器时，操作系统会将 CPU 时间分配给这些不同的程序，使得它们看起来像是在同时运行。这种多任务处理能力极大地提高了计算机的使用效率，让用户可以同时进行多种操作。

## 串行、并行和并发

| **模式** | **特点** | **示例** |
| --- | --- | --- |
| 串行 | 顺序执行，前任务完成才执行后续 | 单线程程序 |
| 并行 | 物理同时执行（需多核支持） | 多核CPU同时计算矩阵乘法 |
| 并发 | 逻辑上同时处理（单核交替执行） | Web服务器同时处理多个请求 |

为了更直观的说明，我们举几个生活上的例子

**串行**：就像你早晨起床后的一系列活动，先穿衣，再洗漱，最后吃早餐，每一项任务必须在前一项完成后才能进行。

```go
 ┌─────────────┐
 │ 任务1：穿衣  │
 └─────────────┘
         │
 ┌─────────────┐
 │ 任务2：洗漱  │
 └─────────────┘
         │
 ┌─────────────┐
 │ 任务3：吃早餐│
 └─────────────┘
```

**并行**：比如一家人做家务, 孩子扫地，爸爸擦窗，妈妈整理杂物。这就如同在拥有 3 个 CPU 核心的计算机中，3 个任务可以在不同核心上同时进行

```go
         ┌─────────────┐  ┌─────────────┐  ┌─────────────┐
         │ 任务1：扫地  │  │ 任务2：擦窗  │  │任务3：整理杂物│
         └─────────────┘  └─────────────┘  └─────────────┘
```

**并发**：假设你是一个咖啡师，只有一个咖啡机。来了三位顾客，你先为第一位顾客研磨咖啡豆，在等待研磨的过程中，你去为第二位顾客准备杯子，接着又去为第三位顾客煮水。通过快速切换任务，让每位顾客感觉自己的需求都在同时被处理。在单核处理器中，操作系统也是这样在多个进程或线程之间快速切换 CPU 时间片来实现并发的。

```go
 ┌──────────────────┐  ┌───────────────┐  ┌─────────────┐
 │ 顾客1：研磨咖啡豆  │  │ 顾客2：准备杯子│  │ 顾客3：煮水  │
 └──────────────────┘  └───────────────┘  └─────────────┘
         │                   │                │
 ┌─────────────────┐   ┌────────────────┐  ┌─────────────┐
 │ 顾客1：冲泡咖啡  │    │ 顾客2：添加牛奶 │  │ 顾客3：加糖  │
 └─────────────────┘   └────────────────┘  └─────────────┘
```

## 进程、线程和协程

**进程是操作系统进行资源分配和调度的基本单位，每个进程都有独立的内存空间和系统资源**。例如，当你启动一个应用程序，操作系统会为其创建一个进程，该进程拥有自己独立的内存、文件描述符等资源。

**线程是进程中的一个执行单元，是操作系统能够进行运算调度的最小单位**。一个进程可以包含多个线程，这些线程共享进程的资源，如内存空间、文件描述符等。例如，在一个 Web 服务器进程中，可以有多个线程同时处理不同的客户端请求。

**协程是一种用户态的轻量级线程，由用户程序自己控制调度**。与操作系统线程相比，协程的创建和销毁开销极小，可以轻松创建大量协程。在 Go 语言中，协程被称为 goroutine，它是 Go 语言实现高并发的核心机制

|  | **进程** | **线程** | **协程（Goroutine）** |
| --- | --- | --- | --- |
| 资源占用 | 独立内存空间（MB级） | 共享进程内存（MB级） | 轻量级栈（KB级） |
| 切换成本 | 高（内核态切换） | 中（内核态切换） | 极低（用户态切换） |
| 通信方式 | 管道/信号/共享内存 | 共享内存 | Channel通信 |
| 控制权 | OS调度 | OS调度 | Go运行时调度 |

## 同步与异步

**同步操作是指在执行一个操作时，必须等待该操作完成后才能继续执行后续操作**。例如，在进行文件读取时，程序会一直等待文件读取完成，然后才会继续执行下一步操作。

```go
// 同步文件读取
data := readFileSync("data.txt")
process(data) // 必须等待读取完成
```

特点：

- 执行流与任务顺序严格一致
    - 同步操作的执行顺序与代码编写顺序相同，如同按照既定路线依次前行，一个步骤紧接着下一个步骤。这种严格的顺序性使得代码执行过程可预测，开发者能够清晰地把控程序的运行流程，调试和维护时也更容易理解和追踪。
- 代码逻辑直观
    - 由于执行顺序的确定性，代码逻辑的呈现方式与人类自然的思维习惯相符，即先做什么，再做什么。这使得代码的编写和阅读都相对简单

但是某些情况下的同步操作中，某个任务执行时间较长，例如进行耗时的 I/O 操作（如文件读取、网络请求）时，程序会处于等待状态，在此期间 CPU 资源被闲置，无法被其他任务利用，导致系统资源的浪费，降低了系统的整体效率。所以，可以使用异步操作来提高效率。

**异步操作则是指在执行一个操作后，不需要等待该操作完成，程序可以继续执行其他操作**。当异步操作完成后，会通过回调函数或事件通知程序。例如，在发送网络请求时，可以发起请求后继续执行其他任务，当网络请求完成后，通过回调函数来处理返回的数据。

```go
// 异步文件读取
go func() {
    data := readFileAsync("data.txt")
    process(data)
}()
// 继续执行其他逻辑
```

特点：

- 提高系统吞吐量
- 充分利用CPU资源
- 更快的响应速度
    - 对于一些需要快速响应的应用场景，如用户界面交互、实时通信等，异步操作可以让程序在执行耗时操作的同时，及时响应用户的其他操作，提升用户体验。例如，在一个图形界面应用中，进行文件读取时，如果采用同步操作，界面可能会出现卡顿现象；而采用异步操作，界面可以继续响应用户的点击、滚动等操作，保持流畅性。

但是异步也有很明显的缺点

- 回调地狱（Callback Hell）
    - 当异步操作嵌套层级过多时，会导致大量的回调函数嵌套在一起，使得代码结构混乱，可读性和可维护性极差。例如，在一个需要依次进行多个异步网络请求的场景中，每个请求的回调函数中又包含下一个请求的代码，代码会变得像金字塔一样层层嵌套，修改和调试都非常困难，这就是所谓的 “回调地狱”。
- 状态管理复杂度增加
    - 异步操作的执行顺序不确定，这就使得程序的状态管理变得复杂。在同步操作中，程序的状态按照顺序依次改变，很容易跟踪和管理；而在异步操作中，由于多个任务可能同时处于不同的执行阶段，需要开发者更加小心地处理各种状态变化，确保程序的正确性。例如，在一个涉及多个异步任务的电商购物车系统中，需要准确管理商品添加、删除、修改数量等操作的状态，避免出现数据不一致或错误的情况。
- 错误处理链路复杂
    - 由于异步操作的结果不是立即返回，错误处理也变得更加复杂。在同步操作中，错误可以在操作执行后立即捕获和处理；而在异步操作中，错误可能在回调函数中抛出，需要通过特定的机制将错误传递到合适的位置进行处理。如果异步操作的层级较多，错误处理的链路会变得很长，增加了错误处理的难度和复杂性。

## 什么是并发模型

并发模型定义程序处理并发任务的基础架构方式，用于系统性地协调和管理多个并发任务之间的交互模式以及资源共享策略：

1. **CSP模型**（Go采用）：通过Channel通信
    1. 全称是 Communicating Sequential Processes，即通信顺序进程。CSP 模型强调通过 Channel 进行通信来实现数据交互，避免了共享内存带来的复杂性和数据竞争问题。在 Go 语言中，goroutine 之间通过 Channel 传递消息，从而实现高效的并发编程。
2. **Actor模型**：通过消息直接通信（如Erlang）
    1. 该模型的核心思想是通过消息直接通信。每个 Actor 都是一个独立的实体，拥有自己的状态和行为。Actor 之间通过发送和接收消息进行交互，而不是共享内存。
3. **共享内存模型**：通过锁机制同步（如Java）
    1. 在这种模型中，多个任务通过共享内存来进行数据交互。由于多个任务可能同时访问和修改共享内存，因此需要使用锁、信号量等同步机制来避免数据竞争。例如，Java 在并发编程中，常常使用`synchronized`关键字、`Lock`接口等实现对共享内存的同步访问。

**三大主流模型对比**

| **模型类型** | **典型代表** | **通信方式** | **适用场景** |
| --- | --- | --- | --- |
| 共享内存 | C++/Java | 内存变量+锁 | 高性能计算 |
| Actor模型 | Erlang/Elixir | 直接消息传递 | 分布式系统 |
| CSP模型 | Go | Channel管道 | 高并发服务 |

## 锁

锁是一种用于保护共享资源的同步机制，在并发编程中，其能够确保在同一时刻只有一个任务可以访问被保护的资源，从而避免数据竞争和不一致的问题。

在 Go 语言中，锁的类型主要有以下两种：

- **互斥锁（Mutex）**：互斥锁是最基本的锁类型，其作用是保证在同一时间只有一个 goroutine 能够获取锁，从而访问共享资源，其他试图获取锁的 goroutine 需要等待锁的释放。（换而言之，当一个 goroutine 成功获取到互斥锁后，其他 goroutine 必须等待，直到该 goroutine 释放锁。）
    - 这种机制确保了共享资源在同一时刻只能被一个 goroutine 访问，避免了数据竞争。例如，在多个 goroutine 同时访问和修改共享变量时，使用互斥锁可以保证数据的一致性。
- **读写锁（RWMutex）**：读写锁区分了读操作和写操作，允许多个 goroutine 同时进行读操作，因为读操作不会修改共享资源，所以不会产生数据竞争。但是，在进行写操作时，会独占资源，不允许其他读写操作，以确保数据的一致性。
    - 读写锁适用于读操作频繁、写操作较少的场景，能够提高并发性能。例如，在一个多线程访问共享数据库的场景中，如果读操作远远多于写操作，使用读写锁可以显著提高程序的并发性能。

在 Go 语言中，使用`sync`包提供的`Mutex`和`RWMutex`结构体来实现互斥锁和读写锁。通过调用`Lock`方法获取锁，调用`Unlock`方法释放锁。

在使用锁时，需要注意正确的加锁和解锁操作，避免死锁和不必要的性能开销。同时，要根据具体的业务场景选择合适的锁类型，以实现高效的并发控制。

另外附上**锁使用黄金法则**

1. **最小化临界区**：锁范围内只包含必要操作
2. **固定获取顺序**：预防死锁的关键
3. **超时机制**：sync.Mutex.TryLock（Go1.18+）
4. **层级锁**：复杂场景使用锁组合

## 何时使用并发

### **决策矩阵**

可以借助决策矩阵来分析决定是否使用并发以及如何使用并发（当然了很多程序员经验足够后也能够快速判断何时使用并发）

| **场景类型** | **并发方案** | **收益点** | **风险点** |
| --- | --- | --- | --- |
| I/O 密集型 | 协程池 + 异步 I/O | 显著提高系统吞吐量，减少 I/O 操作等待时间 | 需要合理管理连接数，避免连接过多导致资源耗尽 |
| CPU 密集型 | 并行计算，充分利用多核处理器资源 | 大幅加速计算过程，缩短任务执行时间 | 涉及复杂的同步操作，可能产生额外开销 |
| 实时响应 | 事件驱动模型，如基于事件循环的架构 | 降低系统响应延迟，满足实时性要求 | 系统设计和实现复杂度增加，调试难度加大 |
| 批处理任务 | 流水线模式，将任务分解为多个阶段 | 有效提高资源利用率，减少任务处理时间 | 需要精心设计和控制流程，避免阶段间的阻塞和数据积压 |

**场景类型介绍**

- **I/O 密集型**：这类场景的特点是任务大部分时间都在等待 I/O 操作完成，如网络请求、文件读写等。在 I/O 操作等待数据传输的过程中，CPU 处于空闲状态，此时利用并发技术，如协程池和异步 I/O，可以让 CPU 在等待期间去执行其他任务，从而显著提高系统的整体吞吐量，减少 I/O 操作的等待时间。
- **CPU 密集型**：该场景下的任务主要消耗 CPU 资源，如复杂的数学计算、加密解密等。在这种情况下，利用多核处理器资源进行并行计算，可以将任务分配到不同的核心上同时执行，大幅加速计算过程，缩短任务的执行时间。但并行计算往往涉及复杂的同步操作，如线程同步、数据共享等，这可能会产生额外的开销。
- **实时响应**：对于一些对响应时间要求极高的应用场景，如实时通信、游戏、金融交易系统等，需要系统能够在极短的时间内对外部事件做出响应。采用事件驱动模型，如基于事件循环的架构，可以使系统在事件发生时迅速做出反应，降低响应延迟，满足实时性要求。然而，这种架构的设计和实现通常较为复杂，调试难度也较大。
- **批处理任务**：批处理任务通常需要处理大量的数据，将任务分解为多个阶段，采用流水线模式可以让每个阶段并行处理，有效提高资源利用率。例如，在大数据分析中，数据读取、清洗、分析和存储可以分别作为一个阶段，每个阶段由不同的并发任务处理，从而减少整个任务的处理时间。但流水线模式需要精心设计和控制流程，否则容易出现阶段间的阻塞和数据积压问题。

### **并发收益公式**

```go
并发增益 = (串行时间 - 并行时间) / 串行时间 × 100%
```

### **阿姆达尔定律（Amdahl's Law）**

阿姆达尔定律是计算机领域中一个重要的理论，它量化了并行计算中串行部分对整体性能提升的限制。该定律表明，并行加速受限于程序的串行部分。例如，当串行比例为 10% 时，即便在理想的并行计算环境下，最大加速也不会超过 10 倍。这意味着在进行并发编程时，需要充分考虑程序中串行部分的占比，合理设计并发方案，以实现最佳的性能提升。

## 并发编程的难点

并发编程的难点主要包括数据竞争、死锁、资源竞争和调试困难等。

- 数据竞争是指多个并发任务同时访问和修改共享资源，导致数据不一致的问题。
- 死锁是指两个或多个任务相互等待对方释放资源，导致程序无法继续执行的情况。
- 资源竞争（或者称为竞态条件）是指多个任务竞争有限的系统资源，如 CPU、内存等，可能导致系统性能下降。
- 此外，由于并发程序的执行顺序具有不确定性，调试时很难重现问题，增加了调试的难度。

# Go 并发简介

## Golang 中用于并发的特性或包

场景的有如下几种，系列文章后面都会介绍到

- **channel**：Go 语言中用于在 goroutine 之间进行通信的机制，默认是双向的，也可以定义为单向（发送或者接收）。通过 channel，goroutine 可以安全地传递数据，避免共享内存带来的数据竞争问题。例如，一个 goroutine 可以将计算结果发送到 channel，另一个 goroutine 从 channel 中接收结果进行后续处理。
- **sync.Mutex**：互斥锁，用于保护共享资源，确保同一时间只有一个 goroutine 能够访问该资源，从而避免数据竞争。在多个 goroutine 需要访问共享变量时，可以使用互斥锁来保证数据的一致性。
- **sync.RWMutex**：读写锁，分为读锁和写锁。读数据时上读锁，允许多个 goroutine 同时读取数据；写数据时上写锁，此时数据不可读不可写。在高并发读取、偶尔写入的场景中，读写锁可以提高并发性能。
- **sync.WaitGroup**：任务组，用于等待一组 goroutine 完成。可以通过 Add 方法添加任务数量，通过 Done 方法标记任务完成，通过 Wait 方法阻塞等待所有任务完成。例如，在启动多个 goroutine 进行数据处理后，使用 WaitGroup 等待所有处理完成，再进行下一步操作。
- **sync.Once**：保证 Once 只执行一次，无论在多少个 goroutine 中调用，相关操作只会执行一次。常用于初始化操作，确保资源只被初始化一次。
- **sync.Cond**：条件变量，用来控制某个条件下，goroutine 进入等待时期，等待信号到来，然后重新启动。例如，在生产者 - 消费者模型中，消费者可以通过条件变量等待生产者生产数据，当生产者生产数据后，通过条件变量通知消费者。
- **sync.Pool**：临时对象池，用于存储暂时不用的对象，减少对象的创建和销毁开销。在需要使用对象时，可以从对象池中获取，使用完毕后再放回对象池。
- **sync/atomic**：原子操作，提供了一系列原子操作函数，用于对共享资源进行原子操作，确保操作的原子性，避免数据竞争。例如，对一个共享的计数器进行原子加操作。